<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Christophe Pallier" />
  <title>Automata, Turing Machines and Computers</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" type="text/css" media="screen, projection, print"
    href="css/styles/slidy.css" />
  <script src="css/scripts/slidy.js"
    charset="utf-8" type="text/javascript"></script>
</head>
<body>
<div class="slide titlepage">
  <h1 class="title">Automata, Turing Machines and Computers</h1>
  <p class="author">
Christophe Pallier
  </p>
  <p class="date">Sep. 2018</p>
</div>
<div class="slide" id="TOC">
<ul>
<li><a href="#the-computational-theory-of-mind">The Computational Theory of Mind</a><ul>
<li><a href="#what-is-computation-anyway">What is computation anyway ?</a></li>
</ul></li>
<li><a href="#the-ancestors-of-the-computer-the-automata">The ancestors of the computer: the automata</a></li>
<li><a href="#formal-description-of-an-automaton">Formal description of an automaton</a></li>
<li><a href="#examples-of-transition-diagrams">Examples of transition diagrams</a></li>
<li><a href="#what-is-a-computer">What is a Computer?</a></li>
<li><a href="#register-machines">Register machines</a></li>
<li><a href="#the-seven-secrets-of-computers-revealed">The Seven secrets of computers revealed</a></li>
<li><a href="#programmable-computers">Programmable computers</a></li>
<li><a href="#compilation-and-interpretation">Compilation and interpretation</a></li>
<li><a href="#operating-systems">Operating systems</a></li>
<li><a href="#what-is-a-terminal">What is a Terminal?</a></li>
<li><a href="#how-to-open-a-terminal">How to open a Terminal</a></li>
<li><a href="#the-shell">The shell</a></li>
<li><a href="#disks-directories-and-files">Disks, Directories and files</a></li>
<li><a href="#filenames-directory-structure">filenames, directory structure</a></li>
<li><a href="#working-directory.-absolute-pathnames-vs.relative-pathnames-..">Working directory. Absolute pathnames vs. relative pathnames (..)</a></li>
<li><a href="#what-is-the-path">What is the PATH?</a></li>
<li><a href="#what-is-a-library-or-modulepackage">What is a library (or module/package)?</a></li>
</ul>
</div>
<div id="the-computational-theory-of-mind" class="slide section level1">
<h1>The Computational Theory of Mind</h1>
<p>Cognitive science founding disciplines :</p>
<ul>
<li>Psychology</li>
<li>Linguistics</li>
<li>Philosophy of mind</li>
<li>Neurosciences</li>
<li>Computer science (Cybernetics + AI)</li>
</ul>
<p>Could a machine think? Could the mind itself be a machine?</p>
<p>Computers were designed to simulate the mental operations realized by a human mathematician performing a… computation (see Alan Turing)</p>
<p>The <em>Computational Theory of Mind</em> has been defended and attacked many times.</p>
<div class="figure">
<img src="images/books.png" alt="Books pro and cons the CTM (Boden, Pylyshyn, Dreyfus, Penrose)" />
<p class="caption">Books pro and cons the CTM (Boden, Pylyshyn, Dreyfus, Penrose)</p>
</div>
<p>More readings:</p>
<ul>
<li><p>Zylberberg, Ariel, Stanislas Dehaene, Pieter R. Roelfsema, and Mariano Sigman. 2011. “The Human Turing Machine: A Neural Framework for Mental Programs.” <em>Trends in Cognitive Sciences</em></p></li>
<li><p>Van Gelder, Tim. 1995. “What Might Cognition Be, If Not Computation?:” <em>Journal of Philosophy</em> 92 (7): 345–81.</p></li>
<li><p>Jerry Fodor <em>The Mind does not work that way</em></p></li>
<li><p>Douglas Hoftstader <em>Gödel, Escher &amp; Bach</em>, <em>I am a strange loop</em></p></li>
</ul>
<h2 id="what-is-computation-anyway">What is computation anyway ?</h2>
<p>One common answer is: &quot;Computation is what a ****Turing machine** can do**</p>
<p>But what is a Turing machine?</p>
</div>
<div id="the-ancestors-of-the-computer-the-automata" class="slide section level1">
<h1>The ancestors of the computer: the automata</h1>
<p>An <strong>automaton</strong> is a device designed to automatically follow a predetermined sequence of operations.</p>
<div class="figure">
<img src="images/automata.jpg" alt="Examples of Automata: A vending machine, A clock, Vaucanson’s duck" />
<p class="caption">Examples of Automata: A vending machine, A clock, Vaucanson’s duck</p>
</div>
<p>(see Descartes’ <em>Les Animaux Machines</em> <a href="http://www.ac-grenoble.fr/PhiloSophie/logphil/oeuvres/descarte/newcastl.htm">Lettre au Marquis de Newcastle</a></p>
</div>
<div id="formal-description-of-an-automaton" class="slide section level1">
<h1>Formal description of an automaton</h1>
<p>At a abstract level, an automaton can be formally described by:</p>
<ul>
<li>a set of internal <strong>states</strong></li>
<li>a <strong>transition</strong> table (or diagram) that describes the <strong>events</strong> that lead to changes from one state to the other state.</li>
</ul>
<div class="figure">
<img src="images/fsa-table.png" alt="Diagram and Tabular representation of a finite state automaton" />
<p class="caption">Diagram and Tabular representation of a finite state automaton</p>
</div>
</div>
<div id="examples-of-transition-diagrams" class="slide section level1">
<h1>Examples of transition diagrams</h1>
<div class="figure">
<img src="images/coin-counter.png" alt="The change counter of a vending machine" />
<p class="caption">The change counter of a vending machine</p>
</div>
<div class="figure">
<img src="images/heyjudeflowchart.jpg" alt="Transition Diagram for the lyrics of Hey Jude" />
<p class="caption">Transition Diagram for the lyrics of <em>Hey Jude</em></p>
</div>
<div class="figure">
<img src="images/du_or_sie.jpg" alt="Algorithm to decide if you must use “du” or “sie” in German" />
<p class="caption">Algorithm to decide if you must use “du” or “sie” in German</p>
</div>
<div class="figure">
<img src="images/BengaleseFinch_song_fsa.png" alt="A (Probabilistic) Finite state diagram for Bengalese Finch songs (Berwick et al., 2011 Trends in Cognitive Sciences)" />
<p class="caption">A (Probabilistic) Finite state diagram for Bengalese Finch songs (Berwick et al., 2011 <em>Trends in Cognitive Sciences</em>)</p>
</div>
</div>
<div class="slide section level1">

<p>A Finite State Automaton can be used to generate or recognize regular languages.</p>
<p>In Formal Language Theory, a language is a set of strings.</p>
<p>Examples:</p>
<ul>
<li>{ a, aa, ab, ba, aab, bab, …}</li>
<li>{ ha!, haha!, hahaha!, hahahaha!, …}</li>
<li>{ ab, aabb, aaabbb, … }</li>
<li>{ the set of grammatical English sentences}</li>
</ul>
</div>
<div id="what-is-a-computer" class="slide section level1">
<h1>What is a Computer?</h1>
<p>A computer is basically an automaton augmented with a <em>memory store</em>.</p>
<p>This is particularly clear in the case of the <em>Turing machine</em>, a mathematical model of computation (Turing offered the Turing machine as an analysis of the activity of an (idealised) human mathematician engaged in computing).</p>
<div class="figure">
<img src="images/Turing-Machine0.jpg" alt="A Turing machine = FSA + memory store" />
<p class="caption">A Turing machine = FSA + memory store</p>
</div>
<p>A Turing machine is a finite state machine augmented with a tape and a mechanism to read/write on it.</p>
<p>Read <a href="documents/Penrose_Turing-machines.pdf">Roger Penrose’s chapter’s on Turing machines</a> and <a href="https://en.wikipedia.org/wiki/Turing_machine" class="uri">https://en.wikipedia.org/wiki/Turing_machine</a>. You may laos read the <a href="https://londmathsoc.onlinelibrary.wiley.com/doi/pdf/10.1112/plms/s2-42.1.230">Alan Turing’s seminal paper</a>.</p>
<div class="figure">
<img src="images/turing.png" alt="A table describing a Turing machine: try to simulate it." />
<p class="caption">A table describing a Turing machine: try to simulate it.</p>
</div>
</div>
<div class="slide section level1">

<p>Other computing machines have been invented, yet:</p>
<p>&quot;All attempts to give an exact analysis of the intuitive notion of an effectively calculable function have turned out to be equivalent, in the sense that each analysis offered has been proved to pick out the same class of functions, namely those that are computable by Turing machine.</p>
<p>The concept of effective calculability has turned out to be formalism-independent, in that all these different formalisms pick out exactly the same class of functions.&quot; (B. Jack Copeland “The Church-Turing thesis” in <em>Stanford Encyclopedia of Philosophy Archive</em>)</p>
<p>Another computing model which is closer to actual computers, is the <em>register machine</em>.</p>
</div>
<div id="register-machines" class="slide section level1">
<h1>Register machines</h1>
<p>Read <a href="documents/Dan_Dennett-The_seven_secrets_of_computers_revealed.pdf">The seven secrets of computer power revealed</a>_ (Chapter 24 from Daniel Dennett’s <em>Intuition Pumps and other tools for thinking</em>)</p>
<p>The RogRego computer possesses:</p>
<ul>
<li>a bank of registers, or memory locations, each with a unique <em>address</em> (1, 2, 3, …), and each able to have, as <em>content</em>, a single integer (0, 1, 2, …)</li>
<li><p>a processing unit can execute instructions in a stepwise, one-at-a-time fashion. The processor knows only 3 instructions:</p>
<ul>
<li><strong>End</strong>: finishes the programs</li>
<li><strong>Increment register</strong> with 2 arguments: a register #, an step number</li>
<li><strong>Decrement register and Branch</strong> with 3 arguments, a register number and two step numbers.</li>
</ul></li>
</ul>
<p>An online demo is available at http://proto.atech.tufts.edu/RodRego/</p>
<p>You can enter the following program “ADD[0,1]”, on a machine where Reg0 contains 4 and Reg1 contains 7. Try to explain what it is doing.</p>
<pre><code>1 DEB 0 2 3
2 INC 1 1
3 END</code></pre>
<div class="incremental">
<p>This program adds the content of register 0 to register 1 (destroying the content of 0)</p>
</div>
<div class="incremental">
<p>Exercice: write a program Program 2 “MOVE[4,5]” that moves the content of reg4 intro reg5</p>
</div>
<div class="incremental">
<pre><code>1 DEB 5 1 2
2 DEB 4 3 4
3 INC 5 2
4 END</code></pre>
</div>
<div class="incremental">
<p>Program 3 “COPY[1,3]” copies the content of reg1 into reg3, leaving reg1 unchanged:</p>
<pre><code>1 DEB 3 1 2
2 DEB 4 2 3
3 DEB 1 4 6
4 INC 3 5
5 INC 4 3
6 DEB 4 7 8
7 INC 1 6
8 END</code></pre>
<p>Program 4 (NON DESTRUCTIVE ADD[1,2,3]):</p>
<pre><code> 1 DEB 3 1 2
 2 DEB 4 2 3
 3 DEB 1 4 6
 4 INC 3 5
 5 INC 4 3
 6 DEB 4 7 8
 7 INC 1 6
 8 DEB 2 9 11
 9 INC 3 10
10 INC 4 11
11 DEB 4 12 13
12 INC 2 11
13 END</code></pre>
</div>
<div class="incremental">
<p>Note that <em>conditional branching</em> is the key instruction that gives the power to the machine. Depending on the content of memory, the machine can do either (a) or (b).</p>
</div>
</div>
<div id="the-seven-secrets-of-computers-revealed" class="slide section level1">
<h1>The Seven secrets of computers revealed</h1>
<ol style="list-style-type: decimal">
<li><p>Competence without comprehension. A machine can do perfect arithmetic without having to comprehend what it is doing.</p></li>
<li><p>What a number in a register stands for depends on the program</p></li>
<li><p>The register machine can be designed to discriminate any pattern that can be encoded with numbers (e.g. figures, text, sensory inputs,…)</p></li>
<li><p>Programs can be encoded by numbers.</p></li>
<li><p>All programs can be given a unique number which can be treated as a list of instructions by a Universal Machine.</p></li>
<li><p>all improvements in computers over Turing machine (or Register machine), are simply ways of making them faster</p></li>
<li><p>There is no secret #7</p></li>
</ol>
</div>
<div id="programmable-computers" class="slide section level1">
<h1>Programmable computers</h1>
<ul>
<li><p>The first computers were not programmable. They were hardwired!</p></li>
<li><p>An important milestone was the invention of the <em>programmable</em> computer:</p>
<ul>
<li>a program is a set of instructions stored in memory.</li>
<li>Loaded and executed by a processor.</li>
<li>Such programs are written in machine langage (the language of the processor)</li>
</ul></li>
</ul>
</div>
<div id="compilation-and-interpretation" class="slide section level1">
<h1>Compilation and interpretation</h1>
<p>Programs written in higher-level languages (rather than Machine language) can be either:</p>
<ul>
<li><strong>compiled</strong>, or</li>
<li><strong>interpreted</strong></li>
</ul>
<p>In both cases, you write the program as text files called <strong>source files</strong>.</p>
<p>A <strong>compiler</strong> translates the program into an executable file in machine language. The executable file is standalone, that is, the source code is not needed.</p>
<p>An <strong>interpreter</strong> reads the file and execute the commands one by one. It is slower, but easier to interact with. Disatvantage: you need the interpreter to exectute it.</p>
<div class="figure">
<img src="images/interpret-compile.png" alt="Interpretation and compilation" />
<p class="caption">Interpretation and compilation</p>
</div>
</div>
<div id="operating-systems" class="slide section level1">
<h1>Operating systems</h1>
<p>In the first computers, there was only <strong>one</strong> program running. One would load the program into memory, then run it until it halted. Several Programs were ran in <em>batch mode</em>, in a sequence.</p>
<p>Then, it was realized that computers could <em>time-share</em> between programs, allowing several users (or programs) to share the computer.</p>
<p>This requires an <strong>operating systems</strong> (O.S.). The O.S. is the first program that loads into the computer during the boot. When running:</p>
<ul>
<li><p>The OS controls the hardware (screen/printer/disk/keybord/mouse,…) (drivers)</p></li>
<li>The OS manages all the other programs (processes/tasks/applications).
<ul>
<li>sharing memory</li>
<li>allocating processors and cores</li>
<li>allocating time</li>
</ul>
<p>Check out <em>Task Manager</em> (Windows)/<em>System Monitor</em> (Linux)/ <em>Activity Monitor</em> (Mac)</p></li>
</ul>
<div class="figure">
<img src="images/oses.png" alt="Three popular operating systems" />
<p class="caption">Three popular operating systems</p>
</div>
<p>Different OSes offer different “views” of the computer (e.g. 1 button mouse in Mac, 2 in Windows, 3 in Linux), so often programs are designed to work on one OS (bad!). Prefer multiplatform software (like Python).</p>
<p>Several OS can be installed in a given machine:</p>
<ul>
<li>choice at boot (multiboot)</li>
<li>an OS can run inside a <strong>virtual machine</strong>, that is a program running in another (or the same) OS, and emulating a full computer.</li>
</ul>
</div>
<div id="what-is-a-terminal" class="slide section level1">
<h1>What is a Terminal?</h1>
<div class="figure">
<img src="images/terminals.png" alt="Terminals" />
<p class="caption">Terminals</p>
</div>
<p><strong>Terminal</strong> (or <strong>console</strong>): originaly, a device comprising a keyboard and screen, allowing a human to <em>interact</em> with a computer.</p>
<p>Remarks:</p>
<p>Before keyboards and screens, there were punchcards and printers:</p>
<div class="figure">
<img src="images/PunchedCard.jpg" alt="Early computers had no keyboard, no screen. The input was done through punched cards and output would be printed out" />
<p class="caption">Early computers had no keyboard, no screen. The input was done through punched cards and output would be printed out</p>
</div>
<p>Histoically, terminals used to be a dumb screen/keyboard connected to a central computer.</p>
<div class="figure">
<img src="images/terminals.jpeg" alt="In the mainframe era, many terminals were connected to a single, powerful, computer. Everybody was sharing the same computer" />
<p class="caption">In the mainframe era, many terminals were connected to a single, powerful, computer. Everybody was sharing the same computer</p>
</div>
<ul>
<li>With the advent of <em>Personal Computers</em>, the terminal and the computer became a single apparatus.</li>
</ul>
<p>However, terminals can be <em>virtual</em>. A terminal is a program that let you run text programs. You interact by typing and displaying text. No graphical interface/no mouse.</p>
<p>When you open a terminal, a program called a <strong>shell</strong> is started that displays a prompt, and waits for you to enter commands with the keyboard.</p>
<div class="figure">
<img src="images/terminal.png" alt="Picture of a ‘virtual’ terminal in Linux" />
<p class="caption">Picture of a ‘virtual’ terminal in Linux</p>
</div>
</div>
<div id="how-to-open-a-terminal" class="slide section level1">
<h1>How to open a Terminal</h1>
<ul>
<li><p>Ubuntu-Linux: Ctrl-Alt-T (see <a href="https://help.ubuntu.com/community/UsingTheTerminal" class="uri">https://help.ubuntu.com/community/UsingTheTerminal</a>)</p></li>
<li><p>MacOSX: Open Finder/Applications/Utilities/Terminal (see <a href="http://www.wikihow.com/Get-to-the-Command-Line-on-a-Mac" class="uri">http://www.wikihow.com/Get-to-the-Command-Line-on-a-Mac</a>)</p></li>
<li><p>Windows: Launch Anaconda Prompt</p></li>
</ul>
</div>
<div id="the-shell" class="slide section level1">
<h1>The shell</h1>
<p>Inside the terminal, you are interacting with a program called a <strong>Shell</strong>.</p>
<p>Various <em>Shells</em> exists: under Windows: cmd/powershell; under, Mac/linux: bash/tsch… they speak slighlty different languages.</p>
<p>The shell displays a prompt and waits for you to type commands that it will execute. For example, if you type ipython, it will start the ipython program.</p>
<p>One issue is that you have to know the available commands and the language. By contrast with a Graphical User Interface shell with Windows/Icons/Menus, <strong>Textual shells</strong> have a very poor ergonomy. Yet, there are more powerful. They provides variables, loops,… to facilitate automation of tasks.</p>
<p>For example, to create 20 directories in a single bash command under linux:</p>
<pre><code>for f in 01 02 03 04 05 06 07 08 09 10; do mkdir -p subject_$f/data subject_$f/results; done</code></pre>
<p>To learn more, see Wikipedia’s article on <em>Shell_(Computing)</em>: <a href="http://en.wikipedia.org/wiki/Shell_%28computing%29">http://en.wikipedia.org/wiki/Shell_%28computing%29</a></p>
<p>Good news: you will not need to learn a <em>shell</em> language, only a few commands (pwd/cd/ls/dir) to allow you to navigate the filesystem and run a program.</p>
</div>
<div id="disks-directories-and-files" class="slide section level1">
<h1>Disks, Directories and files</h1>
<p>Most computers (not all) have two kinds of memories: - volatile, fast, memory, which is cleared when the computer is switched off (processor’s caches, RAM) - ‘permanent’, slow, memory, which is not erased when the computer is switched off (DISKS, Flashdrives (=solid-state drives))</p>
<p>The unit of storage is the <strong>file</strong>.</p>
<p>Files are nothing but blobs of bits stored “sequentially” on disks.</p>
<p>A first file could be stored between location 234 and 256, a second file could be stored at location 456.</p>
</div>
<div id="filenames-directory-structure" class="slide section level1">
<h1>filenames, directory structure</h1>
<p>To access a file, one would need to know its location on the disk. To simplify human users’ life, the OS provide a system of “pointers”, that is <strong>filenames</strong> , organised in directories.</p>
<p>To help users further, the directories are organised in a hierarchical structure: a directory can contain filenames and other (sub)directories. The top-level directory is called the <strong>root</strong>.</p>
<div class="figure">
<img src="images/linux_directory_structure.png" alt="Linux directory structure" />
<p class="caption">Linux directory structure</p>
</div>
<p>To locate a file, you must know:</p>
<ul>
<li>its location in the directory structure</li>
<li>its basename</li>
</ul>
<p>Remark: a given file can have several names in the same or various directories (remember: a filename is nothing but a link between a human readable charachter string to a location on the disk)</p>
</div>
<div id="working-directory.-absolute-pathnames-vs.relative-pathnames-.." class="slide section level1">
<h1>Working directory. Absolute pathnames vs. relative pathnames (..)</h1>
<p>It would be tedious to always have to specify the full path of a files (that is, the list of all subdirs from the root)</p>
<p>Here comes the notion of <strong>working directory</strong>: A running program has a working directory and filenames can specified <strong>relative</strong> to this directory.</p>
<p>Suppose you want to access the file pointed to by <code>/users/pallier/documents/thesis.pdf</code>. If the current working directory is <code>/users/pallier</code>, you can just use <code>documents/thesis.pdf</code> (notice the absence of ‘/’ at the beginning).</p>
<p>To determine the current working directory, list its content, and change it:</p>
<ul>
<li>under bash</li>
</ul>
<pre><code>     pwd
     ls
     cd Documents</code></pre>
<ul>
<li>under Windows/cmd</li>
</ul>
<pre><code>     echo %cd%
     dir
     cd Documents</code></pre>
<ul>
<li>under python (or ipython):</li>
</ul>
<pre><code>    import os
    os.getcwd()
    os.listdir(&#39;.&#39;)
    os.chdir(&#39;documents&#39;)
    os.getcwd()</code></pre>
</div>
<div id="what-is-the-path" class="slide section level1">
<h1>What is the PATH?</h1>
<p>A command can simply be a program’s name. Typing it and pressing Enter will start the program.</p>
<p>The shell knows where to look for programs thanks to a special environment variable called the <strong>PATH</strong>.</p>
<p>Under bash</p>
<pre><code>    echo $PATH
    which ls
    which python</code></pre>
<p>Under Windows/DOS:</p>
<pre><code>    echo %PATH%</code></pre>
<p>The PATH variable lists all the directories that contains programs.</p>
<p>It is possible to add new directories to the PATH variable, to access new programs.</p>
<p>bash</p>
<pre><code>export PATH=newdirectory:$PATH</code></pre>
<p>DOS</p>
<pre><code>PATH=newdirectory;%PATH%</code></pre>
</div>
<div id="what-is-a-library-or-modulepackage" class="slide section level1">
<h1>What is a library (or module/package)?</h1>
<p>A set of new functions that extend a language (.DLL (Windows);.a or .so (Linux); framework bundles (MacOs))</p>
<p>Dynamic libraries can be used simultaneously by several processes.</p>
<p>Eg. the function @<span class="citation">@sqrt</span>@@ can be defined once, and called by several programs, saving memory.</p>
<p>In Python, use @<span class="citation">@import</span> library</p>
<pre><code>import math
math.srqt(2)</code></pre>
</div>
</body>
</html>
